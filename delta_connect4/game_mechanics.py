"""DO NOT EDIT THIS FILE!

This is a set of functions written by Delta to
 be used by you during the challenge.

Several functions below may be useful to you and can be imported,
these are clearly marked.
"""

import copy
import os
import pickle
import random
import time
from pathlib import Path
from time import sleep
from typing import Callable, Dict, List, Optional, Tuple

import numpy as np

import pygame.gfxdraw


def choose_move_randomly(board: np.ndarray) -> int:
    """Chooses a move randomly from available moves given the state."""
    return random.choice([col for col in range(8) if not is_column_full(board, col)])


def play_connect_4_game(
    your_choose_move: Callable[[np.ndarray], int],
    opponent_choose_move: Callable[[np.ndarray], int],
    game_speed_multiplier: float = 1,
    render: bool = False,
    verbose: bool = False,
) -> int:
    """Play a game where moves are chosen by `your_choose_move()` and `opponent_choose_move()`. Who
    goes first is chosen at random. You can render the game by setting `render=True`.

    Args:
        your_choose_move: function that chooses move (takes state as input)
        opponent_choose_move: function that picks your opponent's next move
        game_speed_multiplier: multiplies the speed of the game. High == fast
        render: whether to render the game using pygame or not
        verbose: whether to print board states to console. Useful for debugging

    Returns: total_return, which is the sum of return from the game
    """
    total_return = 0
    game = Connect4Env(
        opponent_choose_move,
        render=render,
        verbose=verbose,
        game_speed_multiplier=game_speed_multiplier,
    )
    state, reward, done, _ = game.reset()
    while not done:
        action = your_choose_move(state)
        state, reward, done, _ = game.step(action)
        total_return += reward

    return total_return


def has_won(board: np.ndarray, column_index: int) -> bool:
    """Checks if a player has won based on the most recently-added piece on the board.

    Args:
        board: The board to check for a win
        column_index: The column whose top piece you should
                        check for 4-in-a-row

    Returns: True if game won, False otherwise
    """
    row_idx = get_top_piece_row_index(board, column_index)
    if row_idx is None:
        return False
    return get_piece_longest_line_length(board, (row_idx, column_index)) >= 4


def is_column_full(board: np.ndarray, column_idx: int) -> bool:
    """Checks if a board column is full of pieces.

    Args:
        board: The board to check
        column_idx: The column to check

    Returns:
        True if the column is full, False otherwise
    """
    return board[0, column_idx] != 0


def get_top_piece_row_index(board: np.ndarray, column_idx: int) -> Optional[int]:
    """Gets the row index of the highest piece in a specified column."""
    return next((count for count, element in enumerate(board[:, column_idx]) if element != 0), None)


def place_piece(board: np.ndarray, column_idx: int, player: int = 1) -> Tuple[np.ndarray, int]:
    """Place a piece from a player on the board.  This falls down to the lowest available space in
    the column.

    Args:
        board: board to place the piece on (np array)
        column_idx: column to place the piece in (0 -> 7)
        player: player to place the piece for (1 or -1)

    Returns:
        Tuple of (board, row_index) where the board is updated
         and the row_index is the row index of the added piece.
    """
    local_board = copy.deepcopy(board)
    assert player in {
        1,
        -1,
    }, f"Invalid player: {player}. Player must be 1 or -1"
    # Find the empty spaces in the column
    top_piece_row_index = get_top_piece_row_index(local_board, column_idx)
    assert (
        top_piece_row_index != 0
    ), f"Invalid move! Attempted to place a piece in column {column_idx}, but it's full!"
    # Set item in the board to that player's number
    row_idx = top_piece_row_index - 1 if top_piece_row_index else local_board.shape[0] - 1
    local_board[row_idx, column_idx] = player
    return local_board, row_idx


def get_piece_longest_line_length(board: np.ndarray, piece_location: Tuple[int, int]) -> int:
    """Get the length of the longest line of pieces that a piece is in.

    Args:
        board: The board to check
        piece_location: The location of the piece to check (row, col)

    Returns: The length of the longest line of pieces through this piece
    """
    player = board[piece_location]
    directions = [
        [0, 1],
        [1, 1],
        [1, 0],
        [1, -1],
    ]

    direction_row_lengths = []
    # Try all directions
    for direction in directions:
        # We're looking for the longest line through this piece,
        #  start at the piece with a line of 1
        num_in_a_row = 1

        # Try spaces in positive direction
        steps_in_positive_dir = 1

        # Take steps in positive direction until we hit a space not filled by this player's piece
        row = piece_location[0] + steps_in_positive_dir * direction[0]
        col = piece_location[1] + steps_in_positive_dir * direction[1]
        while 0 <= row < board.shape[0] and 0 <= col < board.shape[1] and board[row, col] == player:
            num_in_a_row += 1
            steps_in_positive_dir += 1
            row = piece_location[0] + steps_in_positive_dir * direction[0]
            col = piece_location[1] + steps_in_positive_dir * direction[1]

        # Try spaces in negative direction
        steps_in_negative_dir = 1

        row = piece_location[0] - steps_in_negative_dir * direction[0]
        col = piece_location[1] - steps_in_negative_dir * direction[1]
        while (
            row in range(board.shape[0])
            and col in range(board.shape[1])
            and board[row, col] == player
        ):
            num_in_a_row += 1
            steps_in_negative_dir += 1
            row = piece_location[0] - steps_in_negative_dir * direction[0]
            col = piece_location[1] - steps_in_negative_dir * direction[1]

        # Add all row lengths in each direction to the list
        direction_row_lengths.append(num_in_a_row)

    # Return the longest row length in all directions for this piece
    return max(direction_row_lengths)


###################################### The env ############################################
class Connect4Env:
    N_ROWS = 6
    N_COLS = 8

    # Constants for rendering
    DISC_SIZE_RATIO = 0.8
    SQUARE_SIZE = 60

    BLUE_COLOR = (23, 93, 222)
    BACKGROUND_COLOR = (19, 72, 162)
    BLACK_COLOR = (0, 0, 0)
    WHITE_COLOR = (255, 255, 255)
    YELLOW_COLOR = (255, 240, 0)
    RED_COLOR = (255, 0, 0)

    def __init__(
        self,
        opponent_choose_move: Callable[[np.ndarray], int] = choose_move_randomly,
        verbose: bool = False,
        render: bool = False,
        game_speed_multiplier: float = 1,
    ):
        self._board_visualizer = np.vectorize(lambda x: "X" if x == 1 else "O" if x == -1 else " ")
        self._opponent_choose_move = opponent_choose_move
        self._screen = None
        self.verbose = verbose
        self.render = render
        self.game_speed_multiplier = game_speed_multiplier
        self.most_recent_col: Optional[int] = None

    def reset(self) -> Tuple:
        """Resets game & takes 1st opponent move if they are chosen to go first."""
        self._board = get_empty_board()
        self._player = random.choice([-1, 1])
        self.done = False
        self.winner = None
        if self.verbose:
            print(f"Starting game. Player {self._player} has first move\n", self)

        if self.render:
            self.render_game()
            time.sleep(1 / self.game_speed_multiplier)

        reward = 0

        if self._player == -1:
            # Negative sign is because both players should see themselves as player 1
            opponent_action = self._opponent_choose_move(-self._board)
            reward = -self._step(opponent_action)

        return self._board, reward, self.done, self.info

    def __repr__(self) -> str:
        return str(self._board_visualizer(self._board)) + "\n"

    @property
    def info(self) -> Dict[str, int]:
        return {"player_to_take_next_move": self._player, "winner": self.winner}

    def _step(self, col: int) -> int:
        """Takes 1 turn, internal to this class.

        Do not call
        """
        assert not self.done, "Game is over, call .reset() to start a new game"
        assert (
            isinstance(col, int) and 0 <= col < self._board.shape[1]
        ), f"Col should be an int between 0 and {self._board.shape[1]}"
        assert not is_column_full(self._board, col), "You can't place a counter in a full column!"

        self._board, row = place_piece(self._board, col, self._player)
        self.most_recent_col = col

        # Check for game completion
        won = has_won(self._board, col)
        board_is_full = board_full(self._board)

        reward = 1 if won else 0
        self.winner = self._player if won else None
        self.done = won or board_is_full

        if self.render:
            self.render_game()
            time.sleep(1 / self.game_speed_multiplier)

        if self.verbose:
            time.sleep(1 / self.game_speed_multiplier)
            print(f"Player {self._player} places counter at row {row}, column {col}")
            print(self)
            if won:
                print(f"Player {self._player} has won!\n")
                if self.render:
                    wait_for_click()
                    wait_for_click()
            elif board_is_full:
                print("Board full. It's a tie!")

        # Change self.player only when game isn't over
        self._player *= 1 if self.done else -1

        return reward

    def step(self, col: int) -> Tuple[np.ndarray, int, bool, Dict[str, int]]:
        """Called by user - takes 2 turns, yours and your opponent's"""
        reward = self._step(col)
        if not self.done:
            # Negative sign is because both players should see themselves as player 1
            opponent_action = self._opponent_choose_move(-self._board)
            opponent_reward = self._step(opponent_action)
            # Negative sign is because the opponent's victory is your loss
            reward -= opponent_reward

        return self._board, reward, self.done, self.info

    def __del__(self):
        """Destructor, quit pygame if game over."""
        if self._screen is not None:
            pygame.quit()

    def render_game(self) -> None:
        """Renders game in pygame."""
        if self._screen is None:
            pygame.init()
            self._screen = pygame.display.set_mode(
                (self.SQUARE_SIZE * self.N_COLS, self.SQUARE_SIZE * self.N_ROWS)
            )

        # Draw background of the board
        pygame.gfxdraw.box(
            self._screen,
            pygame.Rect(
                0,
                0,
                self.N_COLS * self.SQUARE_SIZE,
                self.N_ROWS * self.SQUARE_SIZE,
            ),
            self.BLUE_COLOR,
        )

        if self.winner is not None:
            winning_row = get_top_piece_row_index(self._board, self.most_recent_col)
            winning_line = get_pieces_four_connected(
                self._board, (winning_row, self.most_recent_col)
            )

        # Draw the circles - either as spaces if filled or
        for r in range(self.N_ROWS):
            for c in range(self.N_COLS):
                space = self._board[r, c]
                colour = (
                    self.RED_COLOR
                    if space == 1
                    else self.YELLOW_COLOR if space == -1 else self.BACKGROUND_COLOR
                )

                # Anti-aliased circle drawing
                pygame.gfxdraw.aacircle(
                    self._screen,
                    c * self.SQUARE_SIZE + self.SQUARE_SIZE // 2,
                    r * self.SQUARE_SIZE + self.SQUARE_SIZE // 2,
                    int(self.DISC_SIZE_RATIO * self.SQUARE_SIZE / 2),
                    colour,
                )
                if self.winner is not None:
                    if (r, c) in winning_line:
                        pygame.gfxdraw.filled_circle(
                            self._screen,
                            c * self.SQUARE_SIZE + self.SQUARE_SIZE // 2,
                            r * self.SQUARE_SIZE + self.SQUARE_SIZE // 2,
                            int(self.DISC_SIZE_RATIO * self.SQUARE_SIZE / 1.75),
                            self.WHITE_COLOR,
                        )

                pygame.gfxdraw.filled_circle(
                    self._screen,
                    c * self.SQUARE_SIZE + self.SQUARE_SIZE // 2,
                    r * self.SQUARE_SIZE + self.SQUARE_SIZE // 2,
                    int(self.DISC_SIZE_RATIO * self.SQUARE_SIZE / 2),
                    colour,
                )
        pygame.display.update()


################## THESE FUNCTIONS ARE LESS USEFUL ############################


def board_full(board: np.ndarray) -> bool:
    return np.all(board != 0)


def pos_to_col(pos: Tuple[int, int]) -> int:
    return pos[0] // Connect4Env.SQUARE_SIZE


def human_player(state) -> int:
    while True:
        ev = pygame.event.get()
        for event in ev:
            # handle MOUSEBUTTONUP
            if event.type == pygame.MOUSEBUTTONUP:
                pos = pygame.mouse.get_pos()
                return pos_to_col(pos)


def get_empty_board(num_rows: int = 6, num_cols: int = 8) -> np.ndarray:
    return np.zeros((num_rows, num_cols))


################### Loading and saving dictionaries as files #####################

HERE = Path(__file__).parent.resolve()


def save_dictionary(my_dict: Dict, team_name: str) -> None:
    assert isinstance(
        my_dict, dict
    ), f"train() function should output a dict, but got: {type(my_dict)}"
    assert "/" not in team_name, "Invalid TEAM_NAME. '/' are illegal in TEAM_NAME"

    n_retries = 5
    dict_path = os.path.join(HERE, f"dict_{team_name}.pkl")
    for attempt in range(n_retries):
        try:
            with open(dict_path, "wb") as f:
                pickle.dump(my_dict, f)
            load_dictionary(team_name)
            return
        except Exception as e:
            if attempt == n_retries - 1:
                raise


def load_dictionary(team_name: str, umbrella: Path = HERE) -> Dict:
    dict_path = os.path.join(umbrella, f"dict_{team_name}.pkl")
    with open(dict_path, "rb") as f:
        return pickle.load(f)


def wait_for_click() -> None:
    # If pygame is not initialised, dont wait
    if not pygame.get_init():
        return
    while True:
        for event in pygame.event.get():
            if event.type == pygame.MOUSEBUTTONDOWN:
                return


def get_pieces_four_connected(
    board: np.ndarray, piece_location: Tuple[int, int]
) -> List[Tuple[int, int]]:
    """Adapted from game_mechanics, gets the location of 4 connected pieces. Only call this if you
    know there is a winner.

    Args:
        board: The board to check
        piece_location: The location of the piece to check (row, col)

    Returns: List of (row, col) tuples of the pieces that are four connected
    """
    player = board[piece_location]
    directions = [
        [0, 1],
        [1, 1],
        [1, 0],
        [1, -1],
    ]

    # Try all directions
    for direction in directions:
        connected_four = [piece_location]

        # We're looking for the longest line through this piece,
        #  start at the piece with a line of 1
        num_in_a_row = 1

        # Try spaces in positive direction
        steps_in_positive_dir = 1

        # Take steps in positive direction until we hit a space not filled by this player's piece
        row = piece_location[0] + steps_in_positive_dir * direction[0]
        col = piece_location[1] + steps_in_positive_dir * direction[1]
        while 0 <= row < board.shape[0] and 0 <= col < board.shape[1] and board[row, col] == player:
            connected_four.append((row, col))
            num_in_a_row += 1
            steps_in_positive_dir += 1
            row = piece_location[0] + steps_in_positive_dir * direction[0]
            col = piece_location[1] + steps_in_positive_dir * direction[1]

        # Try spaces in negative direction
        steps_in_negative_dir = 1

        row = piece_location[0] - steps_in_negative_dir * direction[0]
        col = piece_location[1] - steps_in_negative_dir * direction[1]

        while (
            row in range(board.shape[0])
            and col in range(board.shape[1])
            and board[row, col] == player
        ):
            connected_four.append((row, col))
            num_in_a_row += 1
            steps_in_negative_dir += 1
            row = piece_location[0] - steps_in_negative_dir * direction[0]
            col = piece_location[1] - steps_in_negative_dir * direction[1]
        if len(connected_four) >= 4:
            return connected_four

    raise ValueError("No four connected pieces found")
